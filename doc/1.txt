TCP 基于流,面向连接的协议
粘包 nagle算法
拆包 MSS 最大报文长度 = MTU-固定IP首部-TCP首部长度。报文>MSS，拆开发送
解决办法 a. 消息定长 b. 包尾分割符 c. 消息分为消息头和消息体，头部加入int变量记录消息总长度
丢包 一般是客户端接收到后处理的有问题

滑动窗口 描述接收方的TCP数据缓冲区的大小
拥塞窗口 以2的指数递增的发送数据包，直到超时错误。确定了拥塞窗口的大小




==========================================
java
public int hashCode() {
            int result = (int) (itemId ^ (itemId >>> 32));
            result = 31 * result + (int) (userId ^ (userId >>> 32));
            return result;
        }
====
存储结构

====
nio

====
【多线程】

【锁】
ReentrantLock 公平锁和非公平锁(无视等待队列) 实现lock和serializable 成员变量 final sync  可中断 可定时
sleep(long millis): 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）。允许更低优先级的线程执行
Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。“退让”，它把运行机会让给了同等优先级的其他线程
t.join():指主线程等待t线程终止。 
Obj.wait(),Obj.notify必须在synchronized(Obj){...}语句块内，
wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制。

AQS(AbstractQueuedSynchronizer) ：
AQS，它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）

CAS：
有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

====
jvm
【jvm内存模型】
程序计数器 
当前线程所执行的字节码的行号指示器 - 线程私有
Java虚拟机栈 
每个方法在执行的同时都会创建一个栈帧(Stack Frame)，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程- 线程私有
本地方法栈 本地方法栈与虚拟机栈所发挥的作用是非常相似的，区别仅在于本地方法栈为本地方法服务
Java堆 
存放对象+数组	 	
方法区 
存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据		
运行时常量池 
是方法区的一部分 用于存放编译期间生成的各种字面量和符号引用
直接内存
在JDK 1.4中新加入了 NIO(New Input/Output) 类，引入了一种基于通道(Channel) 与 缓冲区(Buffer) 的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作
【对象内存模型】
Clazz c = new Clazz 步骤: 是否加载检查，对象分配内存，并发处理【cas】，内存空间初始化，对象设置(操作对象头)， init， 
对象头: 
mark word(锁的标记位，哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳) + class pointer(对象对应的class对象/元数据对象的内存地址)
length:
仅数据拥有该属性
对象中的实际数据:
包括了对象的所有成员变量
对齐填充:
Java对象占用空间是8字节对齐的，即所有Java对象占用bytes数必须是8的倍数
64VM节省内存空间：启用指针压缩
【类加载】
class加载-> 验证 -> 准备(在方法区为类变量分配内存并赋初始值) -> 解析(将常量池中的符号引用转化为直接引用。未必按照顺序，因为动态绑定) -> 初始化 -> 使用 -> 卸载
静态绑定 编译期绑定 只有final static private 构造方法
动态绑定 运行时根据具体的对象的类型绑定（大多数场景）

【加载顺序】
构造函数 对象一建立，就会调用与之相应的构造函数
构造代码块{} 对象一建立就运行构造代码块了，而且优先于构造函数执行。构造代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化
静态代码块 随着类的加载而执行，只执行一次，类调用时，先执行静态代码块，然后才执行主函数。
静态内部类的加载过程 静态内部类的加载不需要依附外部类，在使用时才加载。不过在加载静态内部类的过程中也会加载外部类 

【垃圾回收】
1. 那些内存需要回收？(对象是否可以被回收的两种经典算法)
引用计数法：难解决对象之间相互循环引用的问题
可达性分析算法：从 GC Roots 到这个对象不可达
2. 什么时候回收？ （堆的新生代、老年代、永久代的垃圾回收时机，MinorGC 和 FullGC）
3. 如何回收？(垃圾回收算法)
标记清除算法: 先标记再清除
a. 效率问题：标记和清除两个过程的效率都不高
b. 空间问题：产生大量不连续的内存碎片
复制算法:
将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉.适用于对象存活率低的场景，比如新生代(常用)
1*eden + 2*survivor(8:1:1) 因为研究发现，新生代中的对象每次回收都基本上只有10%左右的对象存活 
标记整理算法:
标记整理算法的标记过程类似标记清除算法，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，类似于磁盘整理的过程，该垃圾回收算法适用于对象存活率高的场景（老年代）
分代收集算法:对堆内存不同区域采用不同的策略进行回收可以提高 JVM 的执行效率

在进行垃圾回收时，先将eden区存活对象复制到survivor0区，然后清空eden区，当这个survivor0区也满了时，则将eden区和survivor0区存活对象复制到survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后交换survivor0区和survivor1区的角色（即下次垃圾回收时会扫描Eden区和survivor1区），即保持survivor0区为空，如此往复。特别地，当survivor1区也不足以存放eden区和survivor0区的存活对象时，就将存活对象直接存放到老年代。如果老年代也满了，就会触发一次FullGC，也就是新生代、老年代都进行回收。注意，新生代发生的GC也叫做MinorGC，MinorGC发生频率比较高，不一定等 Eden区满了才触发。

七种垃圾收集器

====
【java反射和动态代理】

【spring aop and ioc】

====
【java nio】

【netty】

====
【高并发内存队列 disruptor】
数组 不用锁 Ring Buffer(作用为生产和消费) （读写指针） ready Buffer (数据写入成功)  
缓存行填充 避免GC 批操作
====
redis

scard key 

====

mysql 性能调优
show engine innodb status;




=====
【0-1背包】
for(i=1;i<row;i++)
    {
        for(j=1;j<col;j++)
        {
            //w[i]>j,第i个物品不装入背包
            value[i][j]=value[i-1][j];
            //w[i]<=j,且第i个物品装入背包后的价值>value[i-1][j],则记录当前最大价值
            int temp=value[i-1][j-w[i]]+v[i];
            if(w[i]<=j && temp>value[i][j])
                value[i][j]=temp;
        }
    }
 即该段程序完成以下n个阶段：
     1：只装入1个物品，确定在各种不同载重量的背包下，能够得到的最大价值
     2：装入2个物品，确定在各种不同载重量的背包下，能够得到的最大价值
     。。。
     n：以此类推，装入n个物品，确定在各种不同载重量的背包下，能够得到的最大价值


【10亿个数找中位数】

分桶法

把所有数划分到各个小区间，把每个数映射到对应的区间里，对每个区间中数的个数进行计数，数一遍各个区间，看看中位数落在哪个区间，若够小，使用基于内存的算法，否则继续划分。

比如数是32位的，根据每个整数的二进制前5位，划分为32个桶，把数放进对应桶中。如果该桶放不下，继续划分，直至内存可以放心为止。统计每个桶中元素个数，算出中位数一定出现在哪个桶中，而且计算出是该桶中的第几大。
